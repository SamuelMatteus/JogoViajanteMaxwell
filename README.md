# JogoViajanteMaxwell
Este é o Trabalho de Estrutura de Dados
Grupo: Alexandre Tinôco e Samuel Mateus

O projeto tem como objetivo implementar um jogo, onde o personagem pricipal se chama Maxwell, o Viajante que vive na cidade de Ubud , e ele possui uma joia que deve para a cidade de Nargumun. Para ele completar a missão, ele se utiliza de um mapa a fim de chegar em seu destino final, contudo todas as vezes que ele vai de uma cidade para outra o nível de poder da joia é modificado(Aumenta ou diminui), dependendo para onde ele vai. Ainda existe algumas regras nesse jogo, como sempre que a joia fique com mais de 7 de poder ou caso acabe as moedas de transporte (Moedas que permitem a viagem entre as cidades, que no caso vale 1 moeda). Sem falar que no mapa há 3 cidades que possuem missões que podem ser acitas por Maxwell permitindo ganhar moedas e poder na joia. E também sempre que Maxwell chegar em uma cidade um mercador aparece e lhe faz algumas perguntas e dependendo das respostas ele ganha ou perde moedas ou ganha poder na joia. Por fim ao chegar na cidade final, caso ele esteja com mais de 10 moedas ele é condecorado como Rei, se chegar com pelo menos 4 moedas ele é condecorado como Lorde, caso contrário o povo o acolhe como servo da coroa. O objetivo do jogo é chegar em Nergumun sem que Maxwell seja alocado como servo.

Para realizarmos o Projeto, criamos no total 3 classes, uma classe 'Cidade', 'Fronteiras', e 'Main'.

Na classe 'Fronteiras', implementada pelo Samuel, que reprensenta as fronteiras entre as cidades, foi feita com três variáveis de instância: 'destino'(Um objeto do tipo "Cidade" que representa a cidade de destino da fronteira), 'moedasDeTransporte' (Um inteiro que representa a quantidade de moedas de transporte necessárias para atravessar a fronteira) e 'poderDaJoia' (Um inteiro que representa o poder da Joia associado à fronteira). Além disso há um construtor que recebe e inicializa as variáveis de instância. Resumindo, cada objeto da classe 'Fronteiras' representa uma fronteira específica entre uma cidade e seu destino, contendo informações como a cidade de destino, o custo de transporte e o poder da Joia associado a essa fronteira.

Já na classe 'Cidade', também implementada pelo Samuel, que representa uma cidade e seus parâmetros, foi feita com duas variáveis de instância: 'nome'(Uma String que armazena o nome da cidade) e 'limites'(Uma lista de objetos do tipo "Fronteiras", que representa as fronteiras da cidade com outras cidades). Nessa classe ainda possui um construtor que recebe o nome da cidade como parâmetro e inicializa a variável 'nome' com o valor fornecido. Além disso, ele cria uma nova lista vazia para armazenar as fronteiras da cidade na variável 'limites'. E por fim ele se utiliza de um método chamado 'adicionarLigacao', responsável por adicionar uma ligação (fronteira) entre a cidade atual e outra cidade. Ele recebe três parâmetros: 'destino' (a cidade de destino da ligação), 'custo' (o custo da ligação) e 'poderDaJoia' (o poder da Joia associado à ligação). Dentro desse método, uma nova instância da classe "Fronteiras" é criada com os parâmetros fornecidos e em seguida essa instância é adicionada à lista 'limites' da cidade atual por meio do método 'add()'.

E por fim a classe 'Main', por ela ser muito extensa eu vou detalha-lá por partes. Da linha 1 à 106, implementada pelo Samuel: Primeiramente é definida a classe 'Main' (Classe principal do programa) dentro dela há um método chamado 'main', que é o ponto de entrada do programa, e recebe um array de strings chamado 'args' como parâmetro e depois imprime uma mensagem de boas vindas para começar o jogo. Em seguida, são criadas várias instâncias da classe 'Cidade', representando as cidades do jogo e cada uma delas é criada com um nome e um valor de "Poder da Jóia", por exemplo, a cidade 'ubud' é criada com o nome "Ubud | Poder da Jóia = 0". Depois de criar todas as cidades, são estabelecidas as conexões entre elas e se utiliza do método 'adicionarLigacao' adiciona uma ligação entre duas cidades, especificando a cidade de destino, a distância entre elas e o poder da jóia necessário para atravessar essa ligação. E nas últimas linhas utilizamos o método 'jogarJogo' com alguns argumentos, que no caso estabelece que no começo do jogo o personagem Maxwell comwça na cidade 'ubud' com 3 moedas de transporte e 0 de poder da joia. Esta parte do código utiliza-se da estrutura de dados chamada grafo, que serviu principalmente pra interligar as cidades umas com as outras, ou seja, permitiu a viagem de Maxwell pelas cidades.

Logo depois disso nas linhas 108 à 150, também implementada pelo Samuel, retoma o método 'jogarJogo' e ele recebe os parâmetros: 'cidadeInicial' (Cidade que Maxwell começa no jogo), 'dinheiroInicial' (Quantidade inicial de moedas de Maxwell) e 'poderDaJoiaInicial' (Poder que a joia começa no jogo). Dentro desse método são inicializadas algumas variáveis: 'cidadeAtual' que recebe a cidade inicial, 'dinheiro' que recebe a quantidade inicial de dinheiro e 'poderJoia' que  recebe o poder inicial da jóia. Além disso, é criada uma lista chamada 'cidadesVisitadas' para armazenar as cidades visitadas durante o jogo. Em seguida, há um loop 'while (true)' que será executado continuamente até que ocorra uma condição de término do jogo e ainda dentro do loop, são exibidas informações sobre a cidade atual, incluindo seu nome, a quantidade de dinheiro disponível e o poder da jóia. Em seguida, o código verifica se existem cidades vizinhas disponíveis para viajar e se não houver nenhuma ligação disponível, o jogo é encerrado. Porém caso existam ligações disponíveis, o código exibe as opções de cidades para viajar e solicita ao jogador que faça uma escolha. Depois da escolha, o código verifica se ela é válida e seja inválida, uma mensagem de erro é exibida e o loop continua e se for válida, o código obtém a cidade escolhida e verifica se o jogador possui dinheiro suficiente para viajar para essa cidade, se não houver dinheiro suficiente, o jogo é encerrado. Se o jogador tiver dinheiro suficiente, o jogo continua, atualizando a cidade atual, subtraindo o valor necessário de dinheiro e continuando o loop executando até que uma condição de término seja atendida, como a falta de ligações disponíveis ou a falta de dinheiro para viajar.

Agora da linha 152 à 179, implementada por Alexandre, após o jogador escolhe uma cidade para viajar, algumas ações são realizadas: A variável 'cidadeAtual' é atualizada para a cidade escolhida ('cidadeEscolhida.destino'), a quantidade de dinheiro é reduzida pelo valor necessário para viajar para a cidade escolhida ('dinheiro -= cidadeEscolhida.moedasDeTransporte'), o poder da jóia é incrementado pelo valor correspondente à cidade escolhida ('poderJoia += cidadeEscolhida.poderDaJoia') e a cidade atual é adicionada à lista de cidades visitadas ('cidadesVisitadas.add(cidadeAtual)'). Depois disso, o código exibe uma mensagem de boas-vindas do mercador da cidade atual, mostrando o nome da cidade, a quantidade de dinheiro disponível e sobre as cidades visitadas (for (Cidade cidade : cidadesVisitadas)) e exibe os nomes das cidades visitadas anteriormente. Para cada cidade visitada, o código pergunta ao jogador se ele deseja trocar suas moedas por limiar na jóia e são exibidas as opções "1. SIM" e "2. NÃO". Em seguida, o código lê a escolha do jogador usando o objeto Scanner chamado mercador e caso o jogador escolher "1" (SIM), o código realiza as seguintes ações: A variável 'aceitarTroca' recebe a soma do poder da jóia atual e a quantidade de dinheiro que o jogador possui, a variável 'aceitarTrocaDinheiro' recebe o valor zero, indicando que todo o dinheiro foi trocado por limiar na jóia, o código exibe o novo poder da jóia ('aceitarTroca') e a quantidade de moedas restante ('aceitarTrocaDinheiro'), a quantidade de dinheiro é atualizada para zero (dinheiro = 0) e o loop continua para a próxima cidade visitada (A troca de moedas por joias depende da quantidade de moedas). Caso não queira trocar o código exibe uma mensagem de despedida do mercador e interrompe o loop 'for', finalizando a interação com o mercador.

Agora da linha 181 à 242, implementada por Alexandre, há verificações de missões disponíveis em determinadas cidades e também o controle do poder da jóia. Em relações as missões, para cada missão disponível em uma cidade específica, é verificado se o nome da cidade atual corresponde à cidade da missão. Se a cidade atual corresponder à cidade da missão, são exibidas as opções "1 - SIM" e "2 - NÃO" para o jogador aceitar ou recusar a missão e em seguida, o código lê a escolha do jogador usando um objeto 'Scanner', porém se o jogador aceitar a missão (escolha igual a 1), são executadas as seguintes ações: Há a exibição de uma mensagem informando que o jogador recebeu uma certa quantidade de moedas, exibe uma mensagem indicando para qual cidade o jogador deve ir em seguida para receber um novo item ("luvas do poder" ou "botas do poder"), a quantidade de moedas da missão é adicionada ao dinheiro do jogador ('dinheiro = dinheiro + moedasAceitarMissao' ou 'dinheiro = dinheiro + moedasAceitarMissaoDefalsia') e o loop é interrompido com o uso do comando break. Se o jogador recusar a missão (escolha igual a 2), é exibida uma mensagem de despedida. Agora em relação ao Controle do poder da jóia, após as verificações das missões, o código realiza algumas ações relacionadas ao poder da jóia. Se o poder da jóia for menor que zero, ele é ajustado para zero (poderJoia = 0), garantindo que o poder mínimo seja zero e se o poder da jóia atingir ou ultrapassar o limite máximo de oito, é exibida uma mensagem informando que a jóia ultrapassou o limite máximo de poder e o jogo é interrompido com o uso do comando break. Essas partes do código permitem ao jogador aceitar ou recusar missões em cidades específicas e controlam o poder da jóia, garantindo que não ultrapasse os limites permitidos.

No trecho final do código da linha 244 à 257, implementada pelo Alexandre, é verificado se a cidade atual é "Nargumun" para determinar se o jogador venceu o jogo. A variável 'vencerJogo' é uma string que contém o nome da cidade "Nargumun" e informações sobre o poder da jóia associado a ela e verifica se o nome da cidade atual corresponde à cidade "Nargumun" usando o método contains() da classe 'String'. Se a cidade atual for "Nargumun", isso significa que o jogador chegou ao final do jogo, e as seguintes ações são executadas: É exibida a mensagem "Parabéns! Você chegou a Nargumun! A jóia foi entregue!" e em seguida, há uma condição 'if' que verifica a quantidade de dinheiro que o jogador possui para determinar o título que ele receberá: Se o dinheiro for maior que 10, é exibida a mensagem "Maxwell é condecorado a rei!" ou caso o dinheiro for igual a 4, é exibida a mensagem "Maxwell é condecorado lorde!" caso o dinheiro for menor que 4, é exibida a mensagem "Maxwell é recebido como servo da coroa de Nargumun!" e depois de tudo o loop é interrompido com o comando 'break'. Em resumo, essa parte do código é responsável por identificar se o jogador chegou à cidade final "Nargumun" e exibir uma mensagem de vitória, além de determinar o título do jogador com base na quantidade de dinheiro que ele possui.

E desta forma o código do Jogo é implementado fazendo com que todas as possíveis possibilidades de jogadas sejam executadas sem erro. As partes que sentimos uma maior dificuldade foi em contabilizar as moedas e o poder da jóia quando o jogador deseja fazer a troca de moedas por poder com o Mercador e também para pensarmos uma maneira de executar as missões ao passar pelas cidades. Mas apesar disso consiguimos ter um melhor apredizado em relação à implementação de códigos em java e um maior entendimento da estrutura de dados Grafos. E assim encerro o relatório do nosso projeto de Estrutura de Dados.
